#!/usr/bin/env ruby
# -*- ruby -*-

require 'json'
require 'fileutils'
require 'tempfile'

$MAILDIR_PREFIX = "~/Mail"

COMA_VERSION = "0.1"

def folder2path(folder)
  if File.directory?(folder + "/cur")
    folder + "/cur"
  elsif File.directory?(folder)
    folder
  else
    case folder
    when /\A\+([\/.~].*)/
      File.expand_path($1) + "/cur"
    when /\A\+(.*)/
      File.expand_path($MAILDIR_PREFIX) + "/" + $1 + "/cur"
    end
  end
end

def folder2cache(folder)
  File.expand_path(folder2path(folder) + "/../.coma.cache")
end

# XXX locking
def with_context
  unless File.directory?(File.expand_path("~/.config/coma"))
    FileUtils.mkdir_p(File.expand_path("~/.config/coma"))
  end
  
  ctx = File.open(contextfile) { |f| JSON.load(f) } rescue {}
  yield ctx
  File.open(contextfile, "w") { |f| f << JSON.pretty_generate(ctx) }
end

def contextfile
  File.expand_path("~/.config/coma/context")
end

def term_width
  # XXX stty would be better; good enough with urxvt/xterm, bash/zsh
  ENV["COLUMNS"].to_i.nonzero? || 80
end

def parse(argv)
  opt = "args"
  opts = {"args" => []}

  argv.each { |arg|
    if arg =~ /\A-/
      opt = $'
      opts[opt] = []
    else
      opts[opt] << arg
    end
  }

  opts
end

def cmd_inc(*argv)
  require 'tmail'

  opts = parse argv

  with_context { |ctx|
    opts['args'].each { |folder|
      ctx['folder'] = folder
      cache = {}
      num = unread = new = 0
      Dir[folder2path(folder) + "/../new/*"].each { |file|
        File.rename file, "#{folder2path(folder)}/#{File.basename(file)}:2,"
        new += 1
      }
      Dir[folder2path(folder) + "/*"].each { |file|
        email = TMail::Mail.parse(File.read(file))
        flags = file[/:2,([a-z]*)/i, 1].to_s.upcase
        
        cache[file] = [email.message_id, email.subject, email.date.to_f,
                       flags, email['from'],
                       email.in_reply_to && email.in_reply_to.first,
                       0]
        num += 1
        unread += 1  unless flags =~ /S/
      }
      
      File.open(folder2cache(folder), "w") { |f| f << JSON.pretty_generate(cache) }
      
      puts "%-20s %5d messages %5d unread %5d new" % [folder, num, unread, new]  unless opts['q']
    }
  }
end

# based on mhthread, mostly works
# 24aug2010  +chris+
def thread(seq, reverse)
  mails = seq.map { |file, mid, subj, date, flags, from, irt, depth|
    re_in_subj = false
    sortsubj = subj.strip.gsub(/^(re\[\d+\][:;]\s*)+/i) {
      re_in_subj = true
      ""
    }

    {:mid => mid, :subj => sortsubj, :orig_subj => subj,
      :re_in_subj => re_in_subj, :irt => irt, :date => date,
      :from => from, :file => file, :flags => flags
    }
  }

  mid2msg = {}
  tree = {}
  toplevel = {}
  subjtop = {}
  subjsets = {}
  subjearliest = {}

  mails.each { |msg|
    mid = msg[:mid]
    irt = msg[:irt]

    mid2msg[mid] = msg
    
    tree[mid] ||= {}
    
    unless irt
      toplevel[mid] = msg
      subjtop[msg[:subj]] = msg  unless msg[:re_in_subj]
      (subjsets[msg[:subj]] ||= []) << msg
      
      if !subjearliest[msg[:subj]] || subjearliest[msg[:subj]] > msg[:date]
        subjearliest[msg[:subj]] = msg[:date]
      end
    else
      tree[irt] ||= {}
      tree[irt][mid] = msg
    end
  }

  tree.each { |mid, _|
    next  if mid2msg[mid]
    
    tree[mid].each { |kid, _|
      msg = mid2msg[kid]
      mid = msg[:mid]
      next  if toplevel[mid]
      
      toplevel[mid] = msg
      subjtop[msg[:subj]] = msg  unless msg[:re_in_subj]
      (subjsets[msg[:subj]] ||= []) << msg
      
      if !subjearliest[msg[:subj]] || subjearliest[msg[:subj]] > msg[:date]
        subjearliest[msg[:subj]] = msg[:date]
      end
    }
  }

  subjsets.each { |subj, _|
    parent = subjtop[subj]
    next  unless parent
    
    subjsets[subj].each { |msg|
      if msg[:re_in_subj]
        tree[parent[mid]][msg[:mid]] = msg
        toplevel.delete msg[:mid]
      end
    }
  }

  sorted = []
  rec = lambda { |level, mid, msg|
    sorted << (msg.values_at(:file, :mid, :orig_subj, :date, :flags, :from, :irt) << level)
    tree[mid].keys.sort_by { |a| mid2msg[a][:date] }.each { |kid|
      rec[level+1, kid, tree[mid][kid]]
    }
  }

  tops = toplevel.keys.sort_by { |mid|
    [ subjearliest[mid].to_s, toplevel[mid][:date] ]
  }
  tops.reverse!  if reverse
  tops.each { |top|
    rec[0, top, toplevel[top]]
  }

  sorted
end

def cmd_read(*argv)
  opts = nil
  with_context { |ctx|
    argv = [ctx['folder'], '-unseen', '-thread']  if argv.empty?
    opts = parse argv

    opts['args'] = [ctx['folder']] if opts['args'].empty?

    seq = []
    
    opts['args'].each { |folder|
      begin
        idx = ref2idx(ctx, folder)
        seq.concat ctx['seq'].values_at(*[*idx].map { |x| x-1 })
        abort "invalid references"  if seq.include?(nil)
      rescue ArgumentError
        if opts['seq']
          seq = ctx['seq']
          mid = seq[ctx['cur']][1]
          p mid
          seq.each { |m|
            m[7] = 0  # reset depth
          }
        else
          cache = File.open(folder2cache(folder)) { |f| JSON.load(f) }
          ctx['folder'] = folder

          cache.each { |k, v|
            seq << [k, *v]
          }
        end
      end
    }

    seq.delete_if { |file, *fields| fields[3] !~ /F/ }  if opts['flagged']
    seq.delete_if { |file, *fields| fields[3] =~ /F/ }  if opts['unflagged']
    seq.delete_if { |file, *fields| fields[3] !~ /S/ }  if opts['seen']
    seq.delete_if { |file, *fields| fields[3] =~ /S/ }  if opts['unseen']
    seq.delete_if { |file, *fields| fields[3] !~ /R/ }  if opts['replied']
    seq.delete_if { |file, *fields| fields[3] =~ /R/ }  if opts['unreplied']
    # -all
    
    if opts['subject']
      seq = seq.sort_by { |file, *fields|
        [opts['limit'] ? fields[2].to_i/(24*60*60*opts['limit'].first.to_i) : 0,
         strip_re(fields[1]),
         fields[2]]
      }
    elsif opts['date']
      seq = seq.sort_by { |file, *fields| fields[2] }
    elsif opts['from']
      seq = seq.sort_by { |file, *fields|
        [opts['limit'] ? fields[2].to_i/(24*60*60*opts['limit'].first.to_i) : 0,
         fields[4],
         fields[2]]
      }
    elsif opts['thread'] || true     # XXX make default configurable
      seq = thread(seq, opts['reverse'])
      opts.delete 'reverse'
    end
    
    seq = seq[-Integer(opts['last'].first || 20)..-1]  if opts['last']
    
    seq.reverse!  if opts['reverse']
    
    ctx['seq'] = seq
    ctx['cur'] = 1
    
    if opts['seq']       # restore cur on -seq.
      seq.each_with_index { |m, i|
        if m[1] == mid
          ctx['cur'] = i
          break
        end
      }
    end
  }

  cmd_scan  unless opts['q']
end

$now = Time.now
def nicedate(t)
  if $now.year == t.year && $now.month == t.month
    if $now.day == t.day
      t.strftime("%H:%M")
    else
      t.strftime("%b %d")
    end
  else
    t.strftime("%Y-%m-%d")
  end
end

def nicefrom(t, size)
  if t =~ /(.*) <.*>/
    t = $1.delete('"')
  end
  t = t.strip.squeeze(" ")
  t[0, size].ljust(size)
end

def strip_re(s)
  s.strip.gsub(/^(re(\[\d+\])?[:;]\s*)+/i) {
    yield  if block_given?
    ""
  }
end

def nicesubj(s, size, depth)
  s = strip_re(s)  if depth > 0
  ("  "*depth + s)[0, size].ljust(size)
end

def cmd_scan(*argv) 
  return cmd_read(*argv)  unless argv.empty?
  opts = parse argv

  # XXX this can be improved.  implement a whole templating language? ugh.
  with_context { |ctx|
    cur = ctx['cur']
    ctx['seq'].each_with_index { |(_,_,s,d,fl,fr,_,depth), i|
# XXX simple two-line format
#      puts "%4d%s%s%s\n%-3s  %s  %s" % [i+1, (i+1 == cur ? "*" : " "),
#                                      "  "*depth, s, fl,
#                                      Time.at(d).strftime("%Y-%m-%d %H:%M"), fr]
      width = opts['width'] ? opts['width'].first.to_i : term_width
      # timely-like single-line format
      puts "%4d%1s%1s%9s  %s  %s\n" % [i+1, (i+1 == cur ? "+" :
                                             (fl !~ /S/ ? "." : " ")),
                                       (fl =~ /R/ ? "-" : " "),
                                       nicedate(Time.at(d)),
                                       nicefrom(fr, 17),
                                       nicesubj(s, width-37, depth)]
    }
  }
end

def ref2idx(ctx, ref)
  case ref
  when "next"
    ref = "+1"
  when "prev"
    ref = "-1"
  when "cur", "."
    ref = "+0"
  end
      
  case ref
  when /.-./
    a, b = ref.split("-", 2)
    ref2idx(ctx, a)..ref2idx(ctx, b)
  when /\A[+-]\d+\z/
    if ctx['seq'][ctx['cur'] - 1 + Integer(ref)]
      ctx['cur'] + Integer(ref)
    else
      raise ArgumentError, "invalid reference"
    end
  when /\A\d+\z/
    Integer(ref)
  when "first"
    1
  when "last"
    ctx['seq'].size
  when "all"
    1..ctx['seq'].size
  when "thread"
    start = ctx['cur']
    while ctx['seq'][start-1][7] > 0 && start >= 1
      start -= 1
    end
    stop = start+1
    while ctx['seq'][stop-1][7] != 0 && stop < ctx['seq'].size
      stop += 1
    end
    start..stop-1
  else
    raise ArgumentError, "invalid reference"
  end
end

def cmd_show(*argv)
  opts = parse argv
  opts['args'] = ["."]  if opts['args'].empty?

  if $stdout.tty? && !opts['nopager']
    $stdout = IO.popen("less -FRWX", "w")
    at_exit { $stdout.close }
  end

  with_context { |ctx|
    opts['args'].each_with_index { |ref, i|
      [*ref2idx(ctx, ref)].each { |idx|
        ctx['cur'] = idx
        file = ctx['seq'][ctx['cur'] - 1][0]
        if opts['path']
          puts file
        elsif opts['raw']
          puts File.read(file)
        elsif opts['idx']
          puts idx
        elsif opts['select']
          # do nothing
        else
          puts "\C-l\n" + "#"*term_width if i > 0
          puts `metamail -B #{file}`
        end
        # XXX mark seen
      }
    }
  }
end

def cmd_next
  cmd_show("next")
rescue ArgumentError
  abort "no more mail"
end

def cmd_prev
  cmd_show("prev")
end

def cmd_folders(*argv)
  num = Hash.new(0)
  unread = Hash.new(0)
  new = Hash.new(0)
  Dir[File.expand_path($MAILDIR_PREFIX) + "/**/cur/*"].each { |file|
    num[File.dirname(file)] += 1
    unread[File.dirname(file)] += 1  unless file =~ /:2,.*S/
  }
  Dir[File.expand_path($MAILDIR_PREFIX) + "/**/new/*"].each { |file|
    new[File.dirname(file).gsub(%r{/new\z}, '/cur')] += 1
  }
  num.keys.sort.each { |folder|
    f = folder.gsub(/\A#{Regexp.quote(File.expand_path($MAILDIR_PREFIX))}\/?/, '+').
    gsub(/\/cur\z/, '')
    puts "%-20s %5d messages %5d unread %5d new" % [f, num[folder], unread[folder], new[folder]]
  }
end

# http://www.jwz.org/doc/mid.html
def generate_mid(from=nil)
  require 'socket'

  timestamp = (Time.now.to_f * 1000).to_i
  random = rand(2**32)
  fqdn = Socket.gethostbyname(Socket.gethostname).first
  if fqdn =~ /localhost/ && from =~ /@(\w*\.\w*)/
    # Better use the hostname in From:.
    fqdn = $1
  end
  "<#{timestamp.to_s(36).upcase}.#{random.to_s(36).upcase}@#{fqdn}>"
end

HEADER_SEP = "--text follows this line--"
def cmd_mail(*argv)
  require 'tmail'

  opts = parse argv
  to = (opts['args'] + opts['to'].to_a).join(", ")
  
  with_context { |ctx|
    if opts['repl']
      ref = opts['repl'].first || "."
      msg = ctx['seq'][ref2idx(ctx, ref) - 1]

      re = TMail::Mail.parse(File.read(msg[0]))
      if re['reply-to'] && !opts['noreplyto']
        to = re['reply-to'].to_s
      else
        to = msg[5]
      end
      opts['cc'] ||= [re.cc.to_s]  unless opts['noreplyall']
      opts['subject'] = ["Re: " + strip_re(msg[2])]
      irt = msg[1]
    elsif opts['fwd']
      ref = opts['fwd'].first || "."
      msg = ctx['seq'][ref2idx(ctx, ref)]
      opts['subject'] = ["Fwd: " + strip_re(msg[2])]
      from = msg[5]
      original_mail = `metamail -B #{msg[0]}`
    end

    Tempfile.open("coma-mail") { |tmp|
      tmp.puts("To: #{to}")
      tmp.puts("Cc: #{opts['cc'].join(", ")}")    if opts['cc']
      tmp.puts("Bcc: #{opts['bcc'].join(", ")}")  if opts['bcc']
      tmp.puts("Subject: #{opts['subject'].to_a.join(" ")}")
      tmp.puts("In-Reply-To: #{irt}")  if irt
      tmp.puts("From: #{opts['from'] || ctx['from']}")  if opts['from'] || ctx['from']
      tmp.puts(HEADER_SEP)
      tmp.puts
      begin
        if original_mail
#          tmp.puts "----- Forwarded message from #{from} -----"
          tmp.puts "#<message/rfc822 <>{inline}"
          tmp.puts original_mail.gsub(/^#/, '##')
          tmp.puts "#"
#          tmp.puts "\n----- End forwarded message -----"
        end

        opts['att'].to_a.each { |att|
          tmp.puts "##{`file --mime-type -bL '#{att}'`.strip} #{att}"
        }

        tmp.puts "--\n" + File.read(File.expand_path("~/.signature"))
      rescue
        # nevermind
      end
      tmp.close
      
      original = File.read(tmp.path)
      system(ENV["VISUAL"] || ENV["EDITOR"] || "vi", tmp.path)
      mail = File.read(tmp.path)
      
      if mail.empty? || mail == original || !mail.index(HEADER_SEP)
        abort "mail canceled"
      end
      
      parsed = TMail::Mail.parse(mail.sub(HEADER_SEP, ""))
      from = parsed.from.to_a.first

      headers, body = mail.split(HEADER_SEP, 2)
      
      headers << "Message-Id: #{generate_mid(from)}\n"
      headers << "X-Mailer: coma/#{COMA_VERSION}\n"

      if body =~ /^#/
        IO.popen("mhbuild -", "w+") { |io|
          io.write body
          io.close_write
          addheaders, body = io.read.split("\n\n", 2)
          headers << addheaders
        }
      end

      if opts['debug']
        puts headers
        puts
        puts body
      else
        IO.popen("sendmail -t", "w") { |out|
          out.write headers
          out.write "\n"
          out.write body
        }
        abort "sendmail failed"  unless $?.success?
      end
    }
  }
end

def cmd_repl(*args)
  cmd_mail("-repl", *args)
end

def cmd_fwd(*args)
  cmd_mail("-fwd", *args)
end

command = ARGV.first || 'usage'
if defined?("cmd_#{command}")
  send "cmd_#{command}", *ARGV[1..-1]
end
