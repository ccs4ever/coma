#!/usr/bin/env ruby
# -*- ruby -*-
# coma - a console mail user agent

require 'fileutils'
require 'strscan'
require 'tempfile'
require 'time'

require 'minimime'

$MAILDIR_PREFIX = "~/Mail"

COMA_VERSION = "0.2"

def folder2path(folder)
  if File.directory?(folder + "/cur")
    folder + "/cur"
  elsif File.directory?(folder)
    folder
  else
    case folder
    when /\A\+([\/.~].*)/
      File.expand_path($1) + "/cur"
    when /\A\+(.+)/
      File.expand_path($MAILDIR_PREFIX) + "/" + $1 + "/cur"
    when "+"  # current folder
      folder2path(with_context { |ctx| ctx['folder'] })
    end
  end
end

def folder2cache(folder)
  File.expand_path(folder2path(folder) + "/../.coma.cache")
end

# XXX locking
def with_context
  unless File.directory?(File.expand_path("~/.config/coma"))
    FileUtils.mkdir_p(File.expand_path("~/.config/coma"))
  end

  ctx = File.open(contextfile) { |f| Marshal.load(f) } rescue {}
  r = yield ctx
  File.open(contextfile, "w") { |f| Marshal.dump(ctx, f) }
  r
end

def contextfile
  File.expand_path("~/.config/coma/context")
end

def term_width
  # XXX stty would be better; good enough with urxvt/xterm, bash/zsh
  ENV["COLUMNS"].to_i.nonzero? || 80
end

def parse(argv)
  opt = "args"
  opts = {"args" => []}

  argv.each { |arg|
    if arg =~ /\A-(?=.)(?!\d)/
      opt = $'
      opts[opt] = []
    else
      opts[opt] << arg
    end
  }

  opts
end

Msg = Struct.new(:file, :mid, :subj, :date, :from, :irt, :idx, :depth)
class Msg
  def flags
    file[/:2,([a-z]*)/i, 1].to_s.upcase
  end

  def flags=(newflags)
    self.file = file.gsub(/:2,([a-z]*)/i, ":2,#{newflags}")
  end
end

def cmd_inc(*argv)
  opts = parse argv

  with_context { |ctx|
    opts['args'].each { |folder|
      ctx['folder'] = folder
      cache = {}
      num = unread = new = 0

      fpath = folder2path(folder)

      begin
        Dir.foreach(File.join(fpath, "/../new/")) { |file|
          next  if file =~ /\A\./
          File.rename file, "#{fpath}/#{File.basename(file)}:2,"
          new += 1
        }
      rescue Errno::ENOENT
        abort "No such folder #{fpath}"
      end
      Dir.foreach(fpath) { |file|
        next  if file =~ /\A\./
        email = MiniMime.new(File.read(File.join(fpath, file)).gsub("\n", "\r\n"))
        msg = Msg.new(file,
                      email["message-id"],
                      email["subject"] || "(no subject)",
                      Time.parse(email["date"]).to_f,
                      email["from"],
                      email["in-reply-to"],
                      nil, 0)
        cache[File.join(fpath,file)] = msg
        num += 1
        unread += 1  unless msg.flags =~ /S/
      }

      File.open(folder2cache(folder), "w") { |f| Marshal.dump(cache, f) }

      puts "%-20s %5d messages %5d unread %5d new" % [folder, num, unread, new]  unless opts['q']
    }
  }
end

# based on mhthread, mostly works
# 24aug2010  +chris+
def thread(seq, reverse)
  mails = seq.map { |file, msg|
    re_in_subj = false
    sortsubj = msg.subj.strip.gsub(/^(re\[\d+\][:;]\s*)+/i) {
      re_in_subj = true
      ""
    }

    {:mid => msg.mid, :subj => sortsubj, :orig_subj => msg.subj,
      :re_in_subj => re_in_subj, :irt => msg.irt, :date => msg.date,
      :from => msg.from, :file => file, :flags => msg.flags, :idx => msg.idx
    }
  }

  mid2msg = {}
  tree = {}
  toplevel = {}
  subjtop = {}
  subjsets = {}
  subjearliest = {}

  mails.each { |msg|
    mid = msg[:mid]
    irt = msg[:irt]

    mid2msg[mid] = msg

    tree[mid] ||= {}

    unless irt
      toplevel[mid] = msg
      subjtop[msg[:subj]] = msg  unless msg[:re_in_subj]
      (subjsets[msg[:subj]] ||= []) << msg

      if !subjearliest[msg[:subj]] || subjearliest[msg[:subj]] > msg[:date]
        subjearliest[msg[:subj]] = msg[:date]
      end
    else
      tree[irt] ||= {}
      tree[irt][mid] = msg
    end
  }

  tree.each { |mid, _|
    next  if mid2msg[mid]

    tree[mid].each { |kid, _|
      msg = mid2msg[kid]
      mid = msg[:mid]
      next  if toplevel[mid]

      toplevel[mid] = msg
      subjtop[msg[:subj]] = msg  unless msg[:re_in_subj]
      (subjsets[msg[:subj]] ||= []) << msg

      if !subjearliest[msg[:subj]] || subjearliest[msg[:subj]] > msg[:date]
        subjearliest[msg[:subj]] = msg[:date]
      end
    }
  }

  subjsets.each { |subj, _|
    parent = subjtop[subj]
    next  unless parent

    subjsets[subj].each { |msg|
      if msg[:re_in_subj]
        tree[parent[mid]][msg[:mid]] = msg
        toplevel.delete msg[:mid]
      end
    }
  }

  sorted = []
  rec = lambda { |level, mid, msg|
    sorted << [msg[:file], Msg.new(*msg.values_at(:file, :mid, :orig_subj, :date, :from, :irt, :idx) << level)]
    tree[mid].keys.sort_by { |a| mid2msg[a][:date] }.each { |kid|
      rec[level+1, kid, tree[mid][kid]]
    }
  }

  tops = toplevel.keys.sort_by { |mid|
    [ subjearliest[mid].to_s, toplevel[mid][:date] ]
  }
  tops.reverse!  if reverse
  tops.each { |top|
    rec[0, top, toplevel[top]]
  }

  sorted
end

$now = Time.now
def nicedate(t)
  if $now.year == t.year && $now.month == t.month
    if $now.day == t.day
      t.strftime("%H:%M")
    else
      t.strftime("%b %d")
    end
  else
    t.strftime("%Y-%m-%d")
  end
end

def nicefrom(t, size)
  if t =~ /(.*) <.*>/
    t = $1.delete('"')
  end
  t = t.strip.squeeze(" ")
  (t + " "*size).unpack("U*")[0, size].pack("U*")
end

def strip_re(s)
  s.strip.gsub(/^(re(\[\d+\])?[:;]\s*)+/i) {
    yield  if block_given?
    ""
  }
end

def nicesubj(s, size, depth)
  s = strip_re(s)  if depth > 0
  ("  "*depth + s).unpack("U*")[0, size].pack("U*").ljust(size)
end

TOKEN = "[-#!$%&'*+.^_{}|\\w]+"
def select(ctx, opts)
  seq = ctx['seq']

  file2idx = {}
  seq.each_with_index { |(file,msg), i| file2idx[file] = i }

  mid = seq[ctx['cur']-1][1].mid  rescue nil

  scanner = StringScanner.new(opts["args"].join(" "))
  seq = expr(scanner, ctx, seq.dup, opts)
  scanner.eos?  or raise "trailing junk"

  seq.each { |(file,msg)| msg.idx = file2idx[file] }

  seq.each_with_index { |(file,msg), i|
    return [seq, msg.idx]  if msg.mid == mid
  }

  [seq, 1]
end

def expr(scanner, ctx, initial, opts)
  seq = initial.dup
  selected = :all
  using_initial = true
  reverse = !!opts['reverse']

  until scanner.eos?
    if scanner.scan(/\s+/)
      # skip whitespace
    elsif scanner.scan(/\(/)
      seq &= expr(scanner, ctx, seq, opts)
    elsif scanner.scan(/\)/)
      break

    elsif scanner.scan(/thread/)
      seq = thread(seq, reverse)
    elsif scanner.scan(/reverse/)
      reverse = !reverse

    elsif scanner.scan(/(next|prev|cur|\.|first|last|all|thr|sub|[+-]?\d+)(:([+-]?(\d+)|thr|sub)|-(next|prev|cur|\.|first|last|all|(\d+)))?/)

      selected = []  if selected == :all
      [*ref2idx(ctx, scanner.matched)].each { |idx|
        selected << idx-1
      }

    elsif scanner.scan(/(#{TOKEN})([:~<>=])(?:('([^']*)'|#{TOKEN}))/)
      seq = seq.find_all { |_, msg|
        pattern = scanner[4] || scanner[3]
        field = case scanner[1]
                when "subj", "subject"; msg.subj
                when "date"; pattern = Time.parse(pattern).to_f; msg.date
                when "from"; msg.from
                else
                  raise "unknown field, add code to load mail"
                end
        case scanner[2]
        when ":"
          pattern.split.any? { |keyword| field =~ /#{keyword}/i }
        when "~"
          field =~ /#{pattern}/
        when "<"
          field < pattern
        when ">"
          field > pattern
        else
          raise "invalid selector #{scanner.matched}"
        end
      }

    elsif scanner.scan(/\+(\S*)/)
      seq = []  if using_initial

      folder = scanner.matched
      begin
        cache = File.open(folder2cache(folder)) { |f| Marshal.load(f) }
      rescue Errno::ENOENT
        abort "coma: could't find cache file, do you need to 'coma inc' first?"
      end
      unless folder == "+"
        ctx['folder'] = folder
      end
      cache.each { |k, v|
        seq << [k, v]
      }
      using_initial = false

    elsif scanner.scan(/\|/)
      seq |= expr(scanner, ctx, initial, opts)
    elsif scanner.scan(/\&/)
      seq &= expr(scanner, ctx, initial, opts)
    elsif scanner.scan(/\\/)
      seq -= expr(scanner, ctx, initial, opts)

    elsif scanner.scan(/flagged/)
      seq = seq.find_all { |_, msg| msg.flags =~ /F/ }
    elsif scanner.scan(/unflagged/)
      seq = seq.find_all { |_, msg| msg.flags !~ /F/ }
    elsif scanner.scan(/seen/)
      seq = seq.find_all { |_, msg| msg.flags =~ /S/ }
    elsif scanner.scan(/unseen/)
      seq = seq.find_all { |_, msg| msg.flags !~ /S/ }
    elsif scanner.scan(/replied/)
      seq = seq.find_all { |_, msg| msg.flags =~ /R/ }
    elsif scanner.scan(/unreplied/)
      seq = seq.find_all { |_, msg| msg.flags !~ /R/ }

    elsif scanner.scan(/subject/)
      seq = seq.sort_by { |file, msg|
        msg.depth = 0  # reset depth
        [opts['limit'] ? msg.date.to_i/(24*60*60*opts['limit'].first.to_i) : 0,
         strip_re(msg.subj),
         msg.date]
      }
      seq.reverse!  if reverse
    elsif scanner.scan(/date/)
      seq = seq.sort_by { |file, msg|
        msg.depth = 0  # reset depth
        msg.date
      }
      seq.reverse!  if reverse
    elsif scanner.scan(/from/)
      seq = seq.sort_by { |file, msg|
        msg.depth = 0  # reset depth
        [opts['limit'] ? msg.date.to_i/(24*60*60*opts['limit'].first.to_i) : 0,
         msg.from,
         msg.date]
      }
      seq.reverse!  if reverse
    else
      raise "can't parse #{scanner.rest.dump}"
    end
  end
  
  seq = seq[-Integer(opts['last'].first || 20)..-1]  if opts['last']

  if selected == :all
    seq
  else
    seq.values_at(*selected).compact
  end
end

def cmd_read(*argv)
  argv << "thread"  unless argv.inspect =~ /date|from|subj/
  argv << "-save"
  cmd_scan(*argv)
end

def cmd_scan(*argv)
  opts = parse argv

  if !opts["args"].empty? && !opts["from"] && !opts["date"] && !opts["subject"]
    opts["thread"] = true
  end

  with_context { |ctx|
    seq, cur = select(ctx, opts)

    if opts["save"]
      seq.each_with_index { |(file, msg), i|
        msg.idx = i
      }
      ctx['seq'] = seq
      ctx['cur'] = cur
    end

    unless opts["q"]
      # XXX this can be improved.  implement a whole templating language? ugh.
      seq.each { |file, msg|
# XXX simple two-line format
#      puts "%4d%s%s%s\n%-3s  %s  %s" % [i+1, (i+1 == cur ? "*" : " "),
#                                      "  "*depth, s, fl,
#                                      Time.at(d).strftime("%Y-%m-%d %H:%M"), fr]
        width = opts['width'] ? opts['width'].first.to_i : term_width
        # timely-like single-line format
        if msg.idx
          idx = msg.idx+1
          flag = (msg.idx == cur ? "+" : nil)
        else
          idx = ''
          flag = nil
        end
        flag ||= (msg.flags !~ /S/ ? "." : " ")
        puts "%4s%1s%1s%10s  %s  %s\n" % [idx,
                                          flag,
                                         (msg.flags =~ /R/ ? "-" : " "),
                                         nicedate(Time.at(msg.date)),
                                         nicefrom(msg.from, 17),
                                         nicesubj(msg.subj, width-37, msg.depth)]
      }
    end
  }
end

def ref2idx(ctx, ref)
  case ref
  when "next"
    ref = "+1"
  when "prev"
    ref = "-1"
  when "cur", "."
    ref = "+0"
  end

  case ref
  when /(.*):([+-]?)(\d+)\z/
    idx = ref2idx(ctx, $1)
    case $2
    when "";  idx..idx+Integer($3)-1 #XXX not MH-style, depends on first/last
    when "+"; idx..idx+Integer($3)-1
    when "-"; idx-Integer($3)+1..idx
    end
  when /.-./
    a, b = ref.split("-", 2)
    ref2idx(ctx, a)..ref2idx(ctx, b)
  when /\A[+-]\d+\z/
    if ctx['seq'][ctx['cur'] - 1 + Integer(ref)]
      ctx['cur'] + Integer(ref)
    else
      raise ArgumentError, "invalid reference"
    end
  when /\A\d+\z/
    Integer(ref)
  when "first"
    1
  when "last"
    ctx['seq'].size
  when "all"
    1..ctx['seq'].size
  when "thr"
    ref2idx(ctx, "cur:thr")
  when /(.*):thr\z/
    start = ref2idx(ctx, $1)
    while ctx['seq'][start-1][1].depth > 0 && start >= 1
      start -= 1
    end
    stop = start+1
    while ctx['seq'][stop-1][1].depth != 0 && stop < ctx['seq'].size
      stop += 1
    end
    start..stop-1
  when "sub"
    ref2idx(ctx, "cur:sub")
  when /(.*):sub\z/
    start = ref2idx(ctx, $1)
    depth = ctx['seq'][start-1][1].depth
    stop = start + 1
    while ctx['seq'][stop-1][1].depth > depth && stop < ctx['seq'].size
      stop += 1
    end
    start..stop-1
  else
    raise ArgumentError, "invalid reference"
  end
end

def metamail(file)
  text = File.read(file)
  # Unix to Internet line conversion.
  text.gsub!("\n", "\r\n")  unless text =~ /\r\n[\t ]*\r\n/m
  MiniMime.new(text).render.gsub("\r\n", "\n")
end

def cmd_show(*argv)
  opts = parse argv
  opts['args'] = ["."]  if opts['args'].empty?

  if $stdout.tty? && !opts['nopager']
    $stdout = IO.popen("less -FRWXe", "w")
    at_exit { $stdout.close }
  end

  seen = []

  with_context { |ctx|
    seq, cur = select(ctx, opts)

    seq.each_with_index { |(file, msg), i|
      p i
      ctx['cur'] = msg.idx+1  if msg.idx
      if opts['path']
        puts file
      elsif opts['raw']
        puts File.read(file)
      elsif opts['idx']
        puts msg.idx+1
      elsif opts['select']
        # do nothing
      else
        puts "\C-l\n" + "#"*term_width  if i > 0
        puts metamail(file)
        seen << (msg.idx+1).to_s  if msg.idx
      end
    }
  }

  cmd_mark(*(seen << "-seen"))  unless opts['keep'] || seen.empty?
end

def cmd_next
  cmd_show("next")
rescue ArgumentError
  abort "no more mail"
end

def cmd_prev
  cmd_show("prev")
end

def cmd_att(*argv)
  opts = parse argv

  with_context { |ctx|
    file = ctx['seq'][ctx['cur'] - 1][0]
    text = File.read(file)
    # Unix to Internet line conversion.
    text.gsub!("\n", "\r\n")  unless text =~ /\r\n[\t ]*\r\n/m

    if opts['args'].empty?
      puts MiniMime.new(text).render_tree
    else
      n, filename, _ = opts['args']
      n = Integer(n)
      name, body = MiniMime.new(text).extract(n)

      name ||= "attachment-#{n}"

      sanitized = name.tr(" ", "-").delete("^a-zA-Z0-9_.-").sub(/\A\.+/, '')
      outfile = filename || sanitized

      if outfile == "-"
        puts body
      else
        if File.exist?(outfile) && !opts['f']
          abort "#{outfile.dump} already exists, use -f to override."
        else
          File.open(outfile, "w") { |out| out << body }
        end
      end
    end
  }
end

def cmd_folders(*argv)
  opts = parse argv

  num = Hash.new(0)
  unread = Hash.new(0)
  new = Hash.new(0)

  if opts['list']
    puts Dir[File.expand_path($MAILDIR_PREFIX) + "/**/cur"].map { |folder|
      f = folder.gsub(/\A#{Regexp.quote(File.expand_path($MAILDIR_PREFIX))}\/?/, '+').
      gsub(/\/cur\z/, '')
    }
    return
  end

  Dir[File.expand_path($MAILDIR_PREFIX) + "/**/cur/*"].each { |file|
    num[File.dirname(file)] += 1
    unread[File.dirname(file)] += 1  unless file =~ /:2,.*S/
  }
  Dir[File.expand_path($MAILDIR_PREFIX) + "/**/new/*"].each { |file|
    new[File.dirname(file).gsub(%r{/new\z}, '/cur')] += 1
  }
  num.keys.sort.each { |folder|
    next  if opts["u"] && unread[folder] + new[folder] == 0

    f = folder.gsub(/\A#{Regexp.quote(File.expand_path($MAILDIR_PREFIX))}\/?/, '+').
    gsub(/\/cur\z/, '')
    if opts["s"]
      puts "%-15s %5d/%3d/%3d" % [f[0,14], num[folder], unread[folder], new[folder]]
    else
      puts "%-20s %5d messages %5d unread %5d new" % [f, num[folder], unread[folder], new[folder]]
    end
  }
end

# http://www.jwz.org/doc/mid.html
def generate_mid(from=nil)
  require 'socket'

  timestamp = (Time.now.to_f * 1000).to_i
  random = rand(2**32)
  fqdn = Socket.gethostbyname(Socket.gethostname).first
  if fqdn =~ /localhost/ && from =~ /@(\w*\.\w*)/
    # Better use the hostname in From:.
    fqdn = $1
  end
  "<#{timestamp.to_s(36).upcase}.#{random.to_s(36).upcase}@#{fqdn}>"
end

HEADER_SEP = "--text follows this line--"
def cmd_mail(*argv)
  opts = parse argv
  to = (opts['args'] + opts['to'].to_a).join(", ")

  with_context { |ctx|
    if opts['repl']
      ref = opts['repl'].first || "."
      file, msg = ctx['seq'][ref2idx(ctx, ref) - 1]

      re = MiniMime.new(File.read(file).gsub("\n", "\r\n"))
      if re['reply-to'] && !opts['noreplyto']
        to = re['reply-to'].to_s
      else
        to = msg.irt
      end
      opts['cc'] ||= [re['cc']]  unless opts['noreplyall'] || !re['cc']
      opts['subject'] = ["Re: " + strip_re(msg.subj)]
      irt = msg.mid
    elsif opts['fwd']
      ref = opts['fwd'].first || "."
      file, msg = ctx['seq'][ref2idx(ctx, ref)]
      opts['subject'] = ["Fwd: " + strip_re(msg.subj)]
      from = msg.from
      original_mail = metamail(file)
    end

    Tempfile.open("coma-mail") { |tmp|
      tmp.puts("To: #{to}")
      tmp.puts("Cc: #{opts['cc'].join(", ")}")    if opts['cc']
      tmp.puts("Bcc: #{opts['bcc'].join(", ")}")  if opts['bcc']
      tmp.puts("Subject: #{opts['subject'].to_a.join(" ")}")
      tmp.puts("In-Reply-To: #{irt}")  if irt
      tmp.puts("From: #{opts['from'] || ctx['from']}")  if opts['from'] || ctx['from']
      tmp.puts(HEADER_SEP)
      tmp.puts
      begin
        if original_mail
#          tmp.puts "----- Forwarded message from #{from} -----"
          tmp.puts "#<message/rfc822 <>{inline}"
          tmp.puts original_mail.gsub(/^#/, '##')
          tmp.puts "#"
#          tmp.puts "\n----- End forwarded message -----"
        end

        opts['att'].to_a.each { |att|
          tmp.puts "##{`file --mime-type -bL '#{att}'`.strip} #{att}"
        }

        tmp.puts "--\n" + File.read(File.expand_path("~/.signature"))
      rescue
        # nevermind
      end
      tmp.close

      original = File.read(tmp.path)
      system(ENV["VISUAL"] || ENV["EDITOR"] || "vi", tmp.path)
      mail = File.read(tmp.path)

      if mail.empty? || mail == original || !mail.index(HEADER_SEP)
        abort "mail canceled"
      end

      parsed = MiniMime.new(mail.sub(HEADER_SEP, "").gsub("\n", "\r\n"))
      from = parsed["from"]

      headers, body = mail.split(HEADER_SEP, 2)

      headers << "Message-Id: #{generate_mid(from)}\n"
      headers << "X-Mailer: coma/#{COMA_VERSION}\n"

      if body =~ /^#/
        IO.popen("mhbuild -", "w+") { |io|
          io.write body
          io.close_write
          addheaders, body = io.read.split("\n\n", 2)
          headers << addheaders
        }
      end

      if opts['debug']
        puts headers
        puts
        puts body
      else
        IO.popen("sendmail -t", "w") { |out|
          out.write headers
          out.write "\n"
          out.write body
        }
        abort "sendmail failed"  unless $?.success?
      end
    }
  }

  if opts['repl'] && !opts['keep']
    cmd_mark(opts['repl'].first || ".", "-replied")
  end
end

def cmd_repl(*argv)
  cmd_mail("-repl", *argv)
end

def cmd_fwd(*argv)
  cmd_mail("-fwd", *argv)
end

def cmd_mark(*argv)
  opts = parse argv

  cache = File.open(folder2cache("+")) { |f| Marshal.load(f) }

  with_context { |ctx|
    seq, cur = select(ctx, opts)
    seq.each_with_index { |(ofile, msg), i|
      file = msg.file.dup
      flags = msg.flags.split(//)

      flags |= ["F"]  if opts['flagged']
      flags -= ["F"]  if opts['unflagged']
      flags |= ["S"]  if opts['seen']
      flags -= ["S"]  if opts['unseen']
      flags |= ["R"]  if opts['replied']
      flags -= ["R"]  if opts['unreplied']

      msg.flags = flags.sort.join

      next  if file == msg.file

      File.rename file, msg.file
      cache[msg.file.dup] = msg
      cache.delete file

      ofile.replace msg.file   # this updates the ctx!
    }
  }

  File.open(folder2cache("+"), "w") { |f| Marshal.dump(cache, f) }
end

def cmd_usage(*argv)
  puts "Subcommands: " + Object.private_instance_methods.grep(/cmd_/).
    map { |cmd| cmd.sub(/^cmd_/, '') }.sort.join(" ")
end

command = ARGV.first || 'usage'
if defined?("cmd_#{command}")
  send "cmd_#{command}", *ARGV[1..-1]
end
